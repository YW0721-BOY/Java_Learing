## 并发
+ 交替执行，随机抽取一个线程工作
## 并行
+ 依次执行，要排队一个一个的执行
## 多线程三种实现方式？

--|优点|缺点
---|---|---
继承Thread类|编程比较简单，可以直接使用Thread类种的方法|可以扩展较差，不能再继承其他类
实现Runnable接口\实现Callable接口|扩展性强，实现该接口同时可以继承其他类|编程相对复杂，不能直接使用Thread类里面的方法

+ Callable接口方式 可以获取结果，其他两种方式不可以

## 线程的优先级
0-5-10
三个级别，优先级越高，越容易获取CPU资源

## 线程生命周期
+ 问题：sleep方法会让线程睡眠，睡眠时间到了之后，立马就会执行下面的代码么？
  + 不会直接执行，先是到达就绪状态，继续抢cpu
## 同步代码块
  把操作共享数据的代码锁起来
+ 特点一：锁默认打开，有一个线程进去，锁自动关闭
+ 特点二：里面的代码全部执行完毕，线程出来，锁自动打开

## 同步方法
就是把synchronized关键字加上
+ 格式：修饰符synchronized返回值类型 方法名（方法参数）{……}
+ 特点1：同步方法是锁住方法里面所有的代码
+ 特点2：锁对象不能自己指定
  + 非静态：this
  + 静态：当前类的字节码文件对象

## Lock锁
虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock

+ Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作
+ Lock种提供了获得锁和释放锁的方法
+ void lock():获得锁
+ void unlock():释放锁


+ Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化
+ ReentrantLock的构造方法
+ ReentrantLock():创建一个ReentrantLock的实例

## 死锁
+ 相当于外边有个锁，里面还有一个锁