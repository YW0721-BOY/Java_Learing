## 并发
+ 交替执行，随机抽取一个线程工作
## 并行
+ 依次执行，要排队一个一个的执行
## 多线程三种实现方式？

--|优点|缺点
---|---|---
继承Thread类|编程比较简单，可以直接使用Thread类种的方法|可以扩展较差，不能再继承其他类
实现Runnable接口\实现Callable接口|扩展性强，实现该接口同时可以继承其他类|编程相对复杂，不能直接使用Thread类里面的方法

+ Callable接口方式 可以获取结果，其他两种方式不可以

## 线程的优先级
0-5-10
三个级别，优先级越高，越容易获取CPU资源

## 线程生命周期
+ 问题：sleep方法会让线程睡眠，睡眠时间到了之后，立马就会执行下面的代码么？
  + 不会直接执行，先是到达就绪状态，继续抢cpu
## 同步代码块
  把操作共享数据的代码锁起来
+ 特点一：锁默认打开，有一个线程进去，锁自动关闭
+ 特点二：里面的代码全部执行完毕，线程出来，锁自动打开

## 同步方法
就是把synchronized关键字加上
+ 格式：修饰符synchronized返回值类型 方法名（方法参数）{……}
+ 特点1：同步方法是锁住方法里面所有的代码
+ 特点2：锁对象不能自己指定
  + 非静态：this
  + 静态：当前类的字节码文件对象

## Lock锁
虽然我们可以理解同步代码块和同步方法的锁对象问题，但是我们并没有直接看到在哪里加上了锁，在哪里释放了锁，为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对象Lock

+ Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作
+ Lock种提供了获得锁和释放锁的方法
+ void lock():获得锁
+ void unlock():释放锁


+ Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化
+ ReentrantLock的构造方法
+ ReentrantLock():创建一个ReentrantLock的实例

## 死锁
+ 相当于外边有个锁，里面还有一个锁

## 生产者和消费者（等待唤醒机制）
生成者消费者模式是一个十分经典的多线程协作的模式
+ 生产者生产一个数据，就唤醒正在等待的消费者
+ 常见方法：

方法名称|说明
---|---
void wait()|当前线程等待，直到被其他线程唤醒
void notify()|随机唤醒单个线程
void notifyAll()|唤醒所有线程


## 等待唤醒机制（阻塞队列方式实现）


## 线程的状态
+ 新建、就绪、运行 死亡、 阻塞、等待、计时等待

## 线程池 主要核心原理
1. 创建一个池子，池子中是空的
2. 提交任务时，池子会创建新的线程对象，任务执行完毕，线程归还给池子，下回再次提交任务时，不需要创建新的线程，直接复用已有的线程即可
3. 但是如果提交任务时，池子中没有空闲线程，也无法创建新的线程，任务就会排队等待

## 自定义线程池
ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor()
(核心线程数量,最大线程数量,空闲线程最大存活时间,任务队列,创建线程工厂,任务的拒绝策略)

            参数一：核心线程数量          不能小于0
            参数二：最大线程数           不能小于等于0，最大数量>=核心线程数量
            参数三：空闲线程最大存活时间   不能小于0
            参数四：时间单位             用TimeUnit指定
            参数五：任务队列             不能为null
            参数六：创建线程工厂          不能为null
            参数七：任务的拒绝策略        不能为null
### 自定义线程池小结
  + 创建一个空的池子
  + 有任务提交时，线程池会创建线程去执行任务，执行完毕归还线程
  
不断的提交任务，会有以下三个临界点
1. 当核心线程满时，再提交任务就会排队
2. 当核心线程满，队伍满时，会创建临时线程
3. 当核心线程满，队伍满，临时线程满时，会触发任务拒绝策略

### 线程池多大合适呢？
+ CPU密集型运算：最大并行数+1
+ I/O密集型运算：最大并行数*期望CPU利用率*总时间（CPU计算时间+等待时间）/CPU计算时间
#### 最大并行数是什么？




